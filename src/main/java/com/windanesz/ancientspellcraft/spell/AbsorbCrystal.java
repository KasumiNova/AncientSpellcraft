package com.windanesz.ancientspellcraft.spell;

import com.windanesz.ancientspellcraft.AncientSpellcraft;
import com.windanesz.ancientspellcraft.registry.ASItems;
import com.windanesz.ancientspellcraft.util.ASUtils;
import com.windanesz.ancientspellcraft.util.WizardArmourUtils;
import electroblob.wizardry.client.DrawingUtils;
import electroblob.wizardry.constants.Element;
import electroblob.wizardry.data.IStoredVariable;
import electroblob.wizardry.data.Persistence;
import electroblob.wizardry.data.WizardData;
import electroblob.wizardry.item.ItemArtefact;
import electroblob.wizardry.item.ItemCrystal;
import electroblob.wizardry.item.ItemWizardArmour;
import electroblob.wizardry.item.SpellActions;
import electroblob.wizardry.registry.WizardryBlocks;
import electroblob.wizardry.spell.Spell;
import electroblob.wizardry.util.ParticleBuilder;
import electroblob.wizardry.util.SpellModifiers;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntityDispenser;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.SoundEvent;
import net.minecraft.world.World;

import java.util.Optional;
import java.util.Random;

public class AbsorbCrystal extends Spell implements IClassSpell {

	public static final IStoredVariable<Integer> ELEMENT = IStoredVariable.StoredVariable.ofInt("AbsorbCrystalElement", Persistence.ALWAYS);

	public AbsorbCrystal() {
		super(AncientSpellcraft.MODID, "absorb_crystal", SpellActions.SUMMON, true);
		WizardData.registerStoredVariables(ELEMENT);
	}

	@Override
	public boolean cast(World world, EntityPlayer caster, EnumHand hand, int ticksInUse, SpellModifiers modifiers) {
		Optional<Element> elementOptional = WizardArmourUtils.getFullSetElementForClassOptional(caster, ItemWizardArmour.ArmourClass.WARLOCK);
		ItemStack crystal = caster.getHeldItemOffhand();
		boolean isBlock = crystal.getItem() == Item.getItemFromBlock(WizardryBlocks.crystal_block);
		if ((!(crystal.getItem() instanceof ItemCrystal) || (isBlock && !ItemArtefact.isArtefactActive(caster, ASItems.ring_absorb_crystal))) || crystal.getItemDamage() == 0) {
			ASUtils.sendMessage(caster, "You must hold an elemental crystal in your offhand", true);
			return false;
		}
		if (ticksInUse % 40 == 0) {
			this.playSound(world, caster, ticksInUse, -1, modifiers);
		}
		if (elementOptional.isPresent()) {
			Element element = elementOptional.get();

			Random rand = caster.world.rand;
			double posX = caster.posX;
			double posY = caster.posY;
			double posZ = caster.posZ;

			if (world.isRemote) {

				if (world.getTotalWorldTime() % 3 == 0) {
					ParticleBuilder.create(WarlockElementalSpellEffects.getElementalParticle(element), rand, posX + rand.nextDouble() * 0.5d * (rand.nextBoolean() ? 1 : -1), posY,
									posZ + rand.nextDouble() * 0.5d * (rand.nextBoolean() ? 1 : -1), 0.03, true).vel(0, 0.3, 0).clr(WarlockElementalSpellEffects.PARTICLE_COLOURS.get(element)[0])
							.time(20 + rand.nextInt(50)).spawn(world);
					ParticleBuilder.create(WarlockElementalSpellEffects.getElementalParticle(element), rand, posX + rand.nextDouble() * 0.5d * (rand.nextBoolean() ? 1 : -1), posY,
									posZ + rand.nextDouble() * 0.5d * (rand.nextBoolean() ? 1 : -1), 0.03, true).vel(0, 0.3, 0).clr(WarlockElementalSpellEffects.PARTICLE_COLOURS.get(element)[1])
							.time(20 + rand.nextInt(50)).spawn(world);

					ParticleBuilder.create(WarlockElementalSpellEffects.getElementalParticle(element), rand, posX + rand.nextDouble() * 0.2d * (rand.nextBoolean() ? 1 : -1), posY,
									posZ + rand.nextDouble() * 0.2d * (rand.nextBoolean() ? 1 : -1), 0.03, true).spin(0.7, 0.05).vel(0, 0.3, 0).clr(WarlockElementalSpellEffects.PARTICLE_COLOURS.get(element)[2])
							.time(20 + rand.nextInt(50)).spawn(world);
				}

				// horizontal particle on the floor, always visible
				ParticleBuilder.create(ParticleBuilder.Type.FLASH)
						.pos(caster.posX, caster.posY + 0.101, caster.posZ)
						.face(EnumFacing.UP)
						.clr(DrawingUtils.mix(WarlockElementalSpellEffects.PARTICLE_COLOURS.get(element)[1], WarlockElementalSpellEffects.PARTICLE_COLOURS.get(element)[2], 0.5f))
						.collide(false)
						.scale(2.3F)
						.time(10)
						.spawn(world);
			} else if (ticksInUse == 60) {
				WizardData data = WizardData.get(caster);
				data.setVariable(ELEMENT, isBlock ? caster.getHeldItemOffhand().getItemDamage() + 7 : caster.getHeldItemOffhand().getItemDamage());
				caster.stopActiveHand();
				ASUtils.sendMessage(caster, "Absorbed " + caster.getHeldItemOffhand().getDisplayName(), true);
				caster.getHeldItemOffhand().shrink(1);
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean canBeCastBy(EntityLiving npc, boolean override) {
		return false;
	}

	@Override
	public boolean canBeCastBy(TileEntityDispenser dispenser) {
		return false;
	}

	@Override
	public ItemWizardArmour.ArmourClass getArmourClass() {
		return ItemWizardArmour.ArmourClass.WARLOCK;
	}

	public static Optional<Element> getElement(WizardData data) {
		if (data.getVariable(ELEMENT) == null) {
			return Optional.empty();
		} else {
			return Optional.of(Element.values()[(int) data.getVariable(ELEMENT) > 7 ? (int) data.getVariable(ELEMENT) -7 : (int) data.getVariable(ELEMENT)]);
		}

	}

	public static boolean isBlock(WizardData data) {
		if (data.getVariable(ELEMENT) == null) {
			return false;
		} else {
			return data.getVariable(ELEMENT) > 7;
		}

	}

	public boolean applicableForItem(Item item) {
		return item == ASItems.forbidden_tome;
	}
}